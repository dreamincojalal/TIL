# TIL
### Today **24.01.22** I learned 데이터 구조<br/>
---
## 1. 데이터 구조
1. 자료구조
    - 컴퓨터 공학에서는 자료구조 라고 함
    - 각 데이터의 효율적인 저장, 관리를 위한 구조를 나눠놓은 것
2. 데이터 구조 활용
    - 문자열, 리스트, 딕셔너리 등 각 데이터 구조의 메서드를 호출하여 다양한 기능 활용하기

---
## 2. 메서드
1. 메서드
    - 객체에 속한 함수(객체의 상태를 조작하거나 동작을 수행)
    - 메서드는 클래스 내부에 정의되는 함수
    - 클래스는 파이썬에서 타입을 표현하는 방법이며 이미 은연중에 사용해왔음
    - help 함수를 이용해 str 함수를 호출해보면 class임을 확인할 수 있음
    - 사용법은 `객체.메서드()`
        - 메서드는 어딘가(클래스)에 속해있는 함수이며, 각 데이터 타입별로 다양한 기능을 가진 메서드가 존재한다.

2. 문자열 조회/탐색 및 검증 메서드
    1. s.find(x) : x의 첫번째 위치를 반환, 없으면 -1 반환
    2. s.index(x) : x의 첫번째 위치를 반환, 없으면 오류 발생
    3. s.isalpha() : 모든 문자열이 알파벳인지 확인, 하나라도 알파벳 아니면 False 반환
    4. s.isupper() : 모든 문자열이 대문자인지 확인(T,F 값 반환)
    5. s.islower() : 모든 문자열이 소문자인지 확인(T,F 값 반환)

3. 문자열 조작 메서드 (str은 불변이기 때문에 새로운 문자열로 반환)
    1. s.replace(old, new[, count]) : 바꿀 대상 굴자를 새로운 글자로 바꿔서 반환
    2. s.strip([chars]) : 문자열의 시작과 끝에 있는 공백 혹은 지정한 문자를 제거
    3. s.split(sep=None, maxsplit = -1) : 지정한 문자를 구분자로 문자열을 분리하여 문자열의 리스트로 반환
    4. 'separator'.join([iterable]) : iterable 요소들을 원래의 문자열을 구분자로 이용하여 하나의 문자열로 연결
    5. s.capitalize() : 첫글자를 대문자로 변경
    6. s.title() : 띄어쓰기 기준으로 각 단어 첫 글자는 대문자로, 나머지는 소문자로 변환
    7. s.upper() : 모두 대문자로 변경
    8. s.lower() : 모두 소문자로 변경
    9. s.swapcase() : 대 <> 소문자 서로 변경

    `메서드는 이어서 사용 가능`

4. 리스트 값 추가 및 삭제 메서드
    1. L.append(x) : 리스트 마지막에 항목 x를 추가
    2. L.extend(iterable) : iterable m의 모든 항목들을 리스트 끝에 추가 (+= 와 같은 기능)
    3. L.insert(i, x) : 리스트 인덱스 i에 항목 x를 삽입
    4. L.remove(x) : 리스트 가장 왼쪽에 있는 항목(첫 번째) x를 제거
    5. L.pop() : 리스트 가장 오른쪽에 있는 항목(마지막)을 반환 후 제거
    6. L.pop(i) : 리스트의 인덱스 i에 있는 항목을 반환 후 제거
    7. L.clear() : 리스트의 모든 항목 삭제(데이터만 삭제)

5. 리스트 탐색 및 정렬 메서드
    1. L.index(x, start, end) : 리스트에 있는 항목 중 가장 왼쪽에 있는 항목 x의 인덱스를 반환
    2. L.reverse() : 리스트의 순서를 역순으로 변경(정렬X)
    3. L.sort() : 리스트를 정렬(매개변수 이용 가능)
    4. L.count() : 리스트의 항목 x의 개수를 반환

---
## 3. 복사
1. 할당
    - 할당 연산자(=)를 통한 복사는 해당 객체에 대한 객체 참조를 복사
    ```
    origin_lst = [1,2,3]
    copy_lst = origin_lst
    print(origin_lst, copy_lst) # [1,2,3] [1,2,3]

    copy_lst[0] = 'hi'
    print(origin_lst, copy_lst) # ['hi',2,3] ['hi',2,3]
    ```

2. 얕은 복사
    - 슬라이싱을 통해 생성된 객체는 원본 객체와 독립적으로 존재
    ```
    a = [1,2,3]
    b = a[:]
    print(a, b) #[1,2,3] [1,2,3]

    b[0] = 100
    print(a, b) #[1,2,3] [100,2,3]
    ```
    - 얕은 복사의 한계
        - 2차원 리스트와 같이 변경 가능한 객체 안에 변경 가능한 객체가 있는 경우
        ```
        a = [1,2,[1,2,]]
        b = a[:]
        print(a, b) #[1,2,[1,2]] [1,2,[1,2]]
        
        b[2][0] = 100
        print(a, b) #[1,2,[1,2]] [1,2,[1,2]]
        ```
        - a와 b의 주소는 다르지만 내부 객체의 주소는 같기 때문에 함께 변경됨

3. 깊은 복사
    - 내부에 중첩된 모든 객체까지 새로운 객체 주소를 참조하도록 함
    - 리스트 깊은 복사 예시
    ```
    import copy

    origin_lst = [1,2,[1,2]]
    deep_copied_lst = copy.deepcopy(origin_lst)

    deep_copied_lst[2][0] = 100

    print(origin_lst) # [1,2,[1,2]]
    print(deep_copied_lst) # [1,2,[100,2]]
    ```

---
## 참고
1. isdecimal()
    - 문자열이 모두 숫자 문자(0~9)로만 이루어져 있어야 True
2. isdigit()
    - isdecimal()과 비슷하지만, 유니코드 숫자도 인식
3. isnumeric()
    - isdigit()과 유사하지만, 몇 가지 추가적인 유니코드 문자들을 인식(분수, 지수, 루트 기호도 숫자로 인식)