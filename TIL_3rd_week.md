# TIL
### Today **24.01.29** I learned 알고리즘<br/>
---
## 1. 시간복잡도
### 1. 빅(O) 표기법
- 시간 복잡도 함수 중에서 가장 큰 영향력을 주는 n에 대한 항 만을 표시한다.
- 계수는 생략하여 표시


## 2. 풀었던 알고리즘
### 1. 투 포인터
- 포인터 두개를 이용하여, 시간복잡도를 줄일 수 있는 풀이법.
- 두개의 포인터가 시작점에서 같이 시작하는 것과, 양 끝에서 시작하는 것으로 나눠져 있다.
    - 백준 3273, 2003

# TIL
### Today **24.01.30** I learned 알고리즘<br/>
---
## 1. 각 정렬들의 시간 복잡도
1. 버블정렬
    - 평균 수행시간 : O(n^2)
    - 최악 수행시간 : O(n^2)
    - 특징 : 코딩이 가장 손쉽다.
2. 카운팅정렬
    - 평균 수행시간 : O(n+k)
    - 최악 수행시간 : O(n+k)
    - 특징 : n(리스트 길이)이 비교적 작을 때만 가능하다.
3. 선택정렬
    - 평균 수행시간 : O(n^2)
    - 최악 수행시간 : O(n^2)
    - 특징 : 교환의 횟수가 버블, 삽입정렬보다 작다.
4. 퀵정렬
    - 평균 수행시간 : O(n log n)
    - 최악 수행시간 : O(n^2)
5. 삽입정렬
    - 평균 수행시간 : O(n^2)
    - 최악 수행시간 : O(n^2)
6. 병합 정렬
    - 평균 수행시간 : O(n log n)
    - 최악 수행시간 : O(n log n)

## 2. 탐욕(Greedy) 알고리즘
- 특징
    1. 여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달
    2. 각 선택의 시점에서 이루어지는 결정은 지역적으로는 최적이지만, 그 선택들을 계속 수집하여 최종적인 해답을 만들었다고 하여, 그것이 최적이라는 보장은 없음.
    3. 일반적으로, 머릿속에 떠오르는 생각을 검증 없이 바로 구현하면 Greedy 접근이 된다.

# TIL
### Today **24.01.31** I learned 2차원 배열<br/>
---
## 1. 2차원 배열
1. 특징
    - 1차원 list를 묶어놓은 list
    - 2차원 이상의 다차원 list는 차원에 따라 index를 선언
    - 2차원 list의 선언 : 세로길이(행의 개수), 가로길이(열의 갯수)를 필요로 함
    - python 에서는 데이터 초기화를 통해 변수선언과 초기화가 가능함
        arr = [[1,2,3,4],[5,6,7,8]](2행 4열의 2차원 list) 

2. 배열 순회
    - n`x`m 배열의 n`*`m개의 모든 원소를 빠짐없이 조사하는 방법
    ```
    # i 행의 좌표
    # j 열의 좌표
    행 우선 순회
    for i in range(n):
    	for j in range(m):
        	print(array[i][j])
    ```
    ```
    열 우선 순회
    for j in range(m):
    	for i in range(n):
        	print(array[i][j])
    ```
    ```
    지그재그 순회
    for i in range(n):
        for j in range(m):
            print(array[i][j+(m-1-2*j)*(i%2)])
    ```
3. 전치 행렬
    ```
    i : 행의 좌표, len(arr)
    j : 열의 좌표, len(arr[0])
    arr = [[1,2,3],[4,5,6],[7,8,9]] # 3*3 행렬

    for i in range(3):
        for j in range(3):
        if i < j:
            arr[i][j], arr[j][i] = arr[j][i], arr[i][j]
    # i != j 일때 순서 바꿔줌
    ```
## 2. 슬라이딩 윈도우
1. 특징
    - 고정 사이즈의 윈도우가 이동하면서 윈도우 내에 있는 데이터를 이용해 문제를 풀이하는 알고리즘
    - 배열, 리스트 요소의 일정 범위의 값을 비교할 때 사용하면 매우 유용

2. 투포인터와의 차이
    - 부분 배열 길이의 변화 여부
    - 투 포인터는 부분 배열의 길이가 가변적이다.
    - 투 포인터는 배열의 구간을 정할 2개의 포인터 변수가 필요하다.
    - 슬라이딩 윈도우 알고리즘은 부분 배열의 길이가 고정적이다.
    - 배열이 고정적인 크기를 가지고 있어, 변수가 하나만 있어도 된다.

3. [슬라이드 윈도우 문제 백준 2559 수열](https://www.acmicpc.net/problem/2559)
    - 풀이법
    ```
    N, K = map(int, input().split())
    lst = list(map(int, input().split()))

    part_sum = sum(lst[:K]) # lst[:K]까지의 합을 part_sum에 할당
    answer = part_sum # part_sum 값을 answer에 저장

    max_V = 0 # 최댓값을 넣을 변수
    for i in range(N-K): # 0부터 N-K+1만큼 반복
        part_sum += lst[i+K]-lst[i] # part_sum 값에 lst의 i번째 값을 빼고, i+K번째 값을 더해준다.
        if answer < part_sum: # 그 값이 더 크면 answer 값 갱신
            answer = part_sum
    
    print(answer)
    ```

# TIL
### Today **24.02.01** I learned 이진검색, 선택정렬<br/>
---
## 1. 검색의 종류 
1. 순차 검색
    1. 특징
        - 일렬로 되어 있는 자료를 순서대로 검색하는 방법
        - 가장 간단하고 직관적인 검색 방법
        - 배열이나 연결 리스트 등 순차구조로 구현된 자료구조에서 원하는 항목을 찾을 때 유용함
        - 알고리즘이 단순하여 구현이 쉽지만, 검색 대상의 수가 많은 경우에는 수행시간이급격히 증가하여 비효율적임
    2. 검색 과정
        - 첫 번째 원소부터 순서대로 검색 대상과 키 값이 같은 원소가 있는지 비교하며 찾는다.
        - 키 값이 동일한 원소를 찾으면 그 원소의 인덱스를 반환한다.
        - 자료구조의 마지막에 이를 때까지 검색 대상을 찾지 못하면 검색 실패
    3. 시간 복잡도
        - O(n)
        - (n+1)/2

2. 이진 검색
    1. 특징
        - 자료의 가운데에 있는 항목의 키 값과 비교하여 다음 검색의 위치를 결정하고 검색을 계속 진행하는 방법
        - 이진검색을 하기 위해서는 자료가 정렬된 상태여야 한다.
    2. 목적
        - 키를 찾을 때까지 이진 검색을 순환적으로 반복 수행함으로써 검색 범위를 반으로 줄여가면서 보다 빠르게 검색을 수행함
    3. 검색과정
        - 자료의 중앙에 있는 원소를 고른다.
        - 중앙 원소의 값과 찾고자 하는 목표 값을 비교한다.
        - 목표 값이 중앙 원소의 값보다 작으면 자료의 왼쪽 반에 대해서 새로 검색을 수행하고, 크다면 자료의 오른쪽 반에 대해서 새로 검색을 수행한다.
        - 찾고자 하는 값을 찾을 때까지 1~3의 과정을 반복한다.
    ```
    def binarySearch(a, N, key):
        # 구간 초기화
        start = 0
        end = N-1
        # left가 right보다 작거나 같을 때 까지만 반복
        while start <= end:
            middle = (start + end)//2 # 중앙값 인덱스
            if a[middle] == key: # 검색 성공
                return True
            elif a[middle] > key: # middle 인덱스 값이 찾고자 하는 값보다 작을 경우
                end = middle - 1 # middle값 이전을 더이상 검색하지 않음
            else:
                start = middle + 1
        return False			# 검색실패
    ```
2. 선택 정렬
    1. 특징
        - 주어진 자료들 중 가장 작은 값의 원소부터 차례대로 선택하여 위치를 교환하는 방식
        - 앞서 살펴본 셀렉션 알고리즘을 전체 자료에 적용한 것이다.
    2. 정렬 과정
        - 주어진 리스트 중에서 최솟값을 찾는다.
        - 그 값을 리스트의 맨 앞에 위치한 값과 교환한다.
        - 맨 처음 위치를 제외한 나머지 리스트를 대상으로 위의 과정을 반복한다.
    3. 시간 복잡도
        - O(n^2)

    ```
    def selection_sort(a, N):
        for i in range(N-1):
            min_idx = i
            for j in range(i+1, N):
                if a[min_idx] > a[j]:
                    min_idx = j
            a[i], a[min_idx] = a[min_idx], a[i]
    ```
3. 셀렉션 알고리즘
    1. 특징
        - 저장되어 있는 자료로부터 k번째로 큰 혹은 작은 원소를 찾는 방법을 셀렉션 알고리즘이라 한다.
        - 최솟값, 최댓값 또는 중간값을 찾는 알고리즘을 의미하기도 한다.
    2. 선택과정
        - 정렬 알고리즘을 이용하여 자료 정렬하기
        - 원하는 순서에 있는 원소 가져오기
        - 1부터 k번째까지 작은 원소들을 찾아 배열의 앞쪽으로 이동시키고, 배열의 k번째를 반환한다.
        - k가 비교적 작을 때 유용하며 O(kn)의 수행시간을 필요로 한다.
    ```
    def selection(arr, k):
        for i in range(0, k):
            min_idx = i
            for j in range(i+1, len(arr)):
                if arr[min_idx] > arr[j]:
                    min_idx = j
            arr[i], arr[min_idx] = arr[min_idx], arr[i]
        return arr[k-1]
    ```
    